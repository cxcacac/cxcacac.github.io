<!DOCTYPE html>
<html lang="en-US">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>
    
      My thoughts &middot; 
    
  </title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="/assets/bootstrap-3.3.7-dist/css/bootstrap.min.css">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
  <!-- My CSS -->
  <link rel="stylesheet" href="/assets/main.css">

  <link rel="shortcut icon" href="/favicon.ico">

<!-- MathJax -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>



  <!-- code highlighting-->
  <link rel="stylesheet" href="/lib/highlight/styles/hybrid.css">
  <script src="/lib/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>hljs.configure({ ignore: ['text'] });</script>
  
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<body>
    <header class="header">
  <!-- Navigation -->
  <nav class="navbar navbar-default .navbar-static-top">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/" style="color:#333">My thoughts</a>
        <p class="navbar-text">Intuitions with enough proficiency are better than theories. </p>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-search">
            <form class="navbar-form navbar-left" role="search" id="search-form">
              <div class="input-group">
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit" style="color:#777">Go!</button>
                  </span>
                  <input type="text" id="search-input" class="form-control" placeholder="Search">
                  
              </div>
            </form>
          </li>
          <li>
            <a href="/archives.html">Archives</a>
          </li>
          <li>
            <a href="/categories.html">Categories</a>
          </li>
          <li>
            <a href="/tags.html">Tags</a>
          </li>
          <li>
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
</header>

  
    <div class="container">
  <div class="row-fluid main">
    <div class="col-md-9 content main-posts-preview">
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-15.html">Leetcode Recorder 15</a>
        </h1>

        <div class="post-info">
          <span class="post-date">15 Feb 2021</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="差分数组995-minimum-number-of-k-consecutive-bit-flips">差分数组：<a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. Minimum Number of K Consecutive Bit Flips</a></h3>

<h3 id="单调队列1438-longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit">单调队列：<a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</a></h3>

<h3 id="限制条件穷举395-longest-substring-with-at-least-k-repeating-characters">限制条件+穷举：<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. Longest Substring with At Least K Repeating Characters</a></h3>

<p>思路：将问题加一个限制条件，转换成能够采用滑动窗口解决的问题，然后将该限制条件进行穷举。</p>

<p>例如：限制每个substring只能最多有n种lower case character，外面加一层循环，将最外层的条件穷举即可。</p>

<h3 id="动态规划位运算338-counting-bits">动态规划+位运算：<a href="https://leetcode-cn.com/problems/counting-bits/">338. Counting Bits</a></h3>

<p>思路：动态规划，重要的是状态表示和转移关系，在转移关系中，除了+1，-1，+2，-2等，还有关于index的位运算，即num[i»1]和num的关系如何。</p>

<h3 id="数组1658-minimum-operations-to-reduce-x-to-zero">数组：<a href="https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/">1658. Minimum Operations to Reduce X to Zero</a></h3>

<p>思路：trick，如果只从数组两端遍历数据，相当于做连续数组，可以用滑动窗口来解题。</p>

<h3 id="字符串算法1392-longest-happy-prefix">字符串算法：<a href="https://leetcode-cn.com/problems/longest-happy-prefix/">1392. Longest Happy Prefix</a></h3>

<p>思路：Robin-Karp算法</p>

        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-15.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-14.html">Leetcode Recorder 14</a>
        </h1>

        <div class="post-info">
          <span class="post-date">15 Dec 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <p>这次刷题，主要是上个月打卡没有写的五道题，都一起写了，并理解了。</p>

<h3 id="没写的">没写的</h3>

<p>（树状数组写法）https://leetcode-cn.com/problems/reverse-pairs/solution/fan-zhuan-dui-by-leetcode-solution/</p>

<p>相似题：</p>

<p>从全局-&gt;局部，从全部-&gt;最优子结构动态规划</p>

<ul>
  <li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a>（困难）</li>
  <li><a href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数</a>（困难）</li>
  <li><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉 K 位数字</a>（中等）</li>
  <li><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/">1081. 不同字符的最小子序列</a>（中等）</li>
</ul>

<p>数据结构：</p>

<p>线段树+树状数组。</p>

<h4 id="327-count-of-range-sum"><a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. Count of Range Sum</a></h4>

<h4 id="493-reverse-pairs"><a href="https://leetcode-cn.com/problems/reverse-pairs/">493. Reverse Pairs</a></h4>

<p>c++语法不会</p>

<h4 id="49-group-anagrams"><a href="https://leetcode-cn.com/problems/group-anagrams/">49. Group Anagrams</a></h4>

<h3 id="动态规划376-wiggle-subsequence">动态规划：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. Wiggle Subsequence</a></h3>

<p>思路：对于该问题而言，关键要找到合适的状态进行表示，如果要满足$O(n)$的时间复杂度，需要以前i个序列的解作为状态，然后进行循环即可，不可以包含最后一个元素的状态进行求解。</p>

<p>如果要以前i个序列作为合适的状态，需要确定最优子结构的转换关系。</p>

<p>设置两个dp数组为up, down，分别表示该序列为上升子序列的解，或者该序列为下降子序列的解，<strong>然后根据nums[i]与nums[i-1]的关系判断上升子序列的更新和下降子序列的更新。</strong></p>

<h3 id="哈希表和函数关系290-word-pattern">哈希表和函数关系：<a href="https://leetcode-cn.com/problems/word-pattern/">290. Word Pattern</a></h3>

<p>思路：一层哈希表其实就是一层函数关系，比如实现$x\rightarrow y$的映射关系，其实就是建立$hash(x) \rightarrow y$，然后如果是双射(bijection)，即一一对应关系，就是建立两个哈希表，即$hash(x)\rightarrow y, hash(y)\rightarrow x$。</p>

<p>在条件句中，如果建立联系就是：如果当前集合包含该元素，就必须对应另外一个元素（两个判断），否则就直接建立双向联系。</p>

<h3 id="单调栈316-remove-duplicate-letters">单调栈：<a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. Remove Duplicate Letters</a></h3>

<p>思路：单调栈就是维护相对顺序保持不变的升序或者降序序列，符合该题的预期。对于去除重复字符的字符串而言，如果要使字典序最小小，最重要的是保证其字符是按照升序排列的。</p>

<h3 id="并查集803-bricks-falling-when-hit">并查集：<a href="https://leetcode-cn.com/problems/bricks-falling-when-hit/">803. Bricks Falling When Hit</a></h3>

<p>思路：打砖块或者打气球，气球从有到无的变化可能难以建立联系，但是有时候从逆向的角度，气球从无到有的话，带来的变化可能是可以做的。</p>

<h3 id="数组1232-check-if-it-is-a-straight-line">数组：<a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. Check If It Is a Straight Line</a></h3>

<p>思路：对该数组的第一个元素和第零个元素而言，是恒满足条件的，可以通过赋初值来解决问题，不需要那么多的假设条件。</p>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-14.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-13.html">Leetcode Recorder 13</a>
        </h1>

        <div class="post-info">
          <span class="post-date">30 Nov 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="基数排序164-maximum-gap">基数排序：<a href="https://leetcode-cn.com/problems/maximum-gap/">164. Maximum Gap</a></h3>

<p>题思路：主要是排序算法满足$O(N)$时间复杂度的要求，只有基数排序和桶排序，这里主要复习一下基数排序的内容。</p>

<p><strong>基数排序</strong>：</p>

<p>思路：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>

<p>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。这种排序方式要和数组更新方式，遍历数组的方式保持一致性。</p>

<p>基数排序一般要快过基于比较的排序，比如快速排序，但是也要看比较的位数和n的大小关系，而且基数排序适用于整数排序，应用场景比较受限。</p>

<p>Radix sort API:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">exp</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">maximum</span> <span class="o">=</span> <span class="o">*</span><span class="n">max_element</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="k">while</span><span class="p">(</span><span class="n">exp</span> <span class="o">&lt;=</span> <span class="n">maximum</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cnt</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="o">:</span><span class="n">nums</span><span class="p">){</span>
        <span class="c1">// for内的变量也是局部变量。</span>
        <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">exp</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="c1">// 关键是按基数的位置再次排数据。</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">exp</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="c1">// 放到当前digit对应的最后一个元素的位置，然后再--；</span>
       	<span class="c1">// 即先处理的大的元素，是放在最后面。</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">cnt</span><span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">digit</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">exp</span><span class="o">*=</span><span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="归并排序493-reverse-pairs">归并排序：<a href="https://leetcode-cn.com/problems/reverse-pairs/">493. Reverse Pairs</a></h3>

<p>思路：归并排序的基本思路还是分治法，该题可以用分治法来处理。也可以说归并排序就是在分治的时候创建sorted数组，根据分治的结果双指针填满sorted数组，然后将sorted数组对原数组进行修改，使原数组满足有序性。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">reversePairsRecursive</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">reversePairsRecursive</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">reversePairsRecursive</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">;</span>

        <span class="c1">// 首先统计下标对的数量</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 随后合并两个排序数组</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sorted</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sorted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="贪心861-score-after-flipping-matrix">贪心：<a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">861. Score After Flipping Matrix</a></h3>

<p>思路：分析该问题的特征，确保前面的元素权重是恒大于后面元素的权重，就可以用贪心处理。进制问题一般都有前面的元素恒大于后面的所有元素的最利情况，所以可以用贪心处理。</p>

<h3 id="回溯842-split-array-into-fibonacci-sequence">回溯：<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">842. Split Array into Fibonacci Sequence</a></h3>

<p>思路：根据状态进行判定和枚举，标准的回溯法。在c++中，回溯法要记得留终结状态的数据，不然就是list.push_back之后list.pop_back，回溯完成就return; 什么都没有留下。</p>

<h3 id="贪心621-task-scheduler">贪心：<a href="https://leetcode-cn.com/problems/task-scheduler/">621. Task Scheduler</a></h3>

<p>思路：贪心，选择对当前任务而言，出现频次最高的任务，可以证明为最优解。</p>

<p>证明：</p>

<p>贪心的数学归纳反证法思路：（1）证明选择与当前贪心不同的策略，总target函数只会变成最优解及以下。（2）证明当前选择用贪心策略，可以至少得到比当前解更优的决策。</p>

<p>这里采用模拟的思路，当用模拟的思路时，每个元素都必须有一个状态，来表征元素和当前进程的关系，可以在合适的时候处理元素，比如该题有（nextValidTime, rest）来表示当前的状态。</p>

<h3 id="前缀和归并排序327-count-of-range-sum">前缀和+归并排序：<a href="https://leetcode-cn.com/problems/count-of-range-sum/">327. Count of Range Sum</a></h3>

<p>思路：对于连续区间的加和满足要求的问题，一般都采用前缀和的思路，但是前缀和的时间复杂度是$O(n^2)$。</p>

<p>前缀和将连续区间转换为下标的问题，即元素之间的相对位置是不变的，最后结果就是不变的。</p>

<p>利用归并排序，子结构的相对位置关系，可以优化时间复杂度，对当前结构的归并排序而言，其子结构<code class="language-plaintext highlighter-rouge">left-mid, mid-right</code>都是已经排好序的，所以在操作子结构时需要进行假设，但是最后需要对有序子结构进行合并。</p>

<p>NOTE: 为了使前缀和<code class="language-plaintext highlighter-rouge">pre[j]-pre[i]=sum(arr[i]+...+arr[j-1])</code>满足要求，需要使pre[0]=0，即前缀和的一个元素是人为添加的0。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">countRangeSumRecursive</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;&amp;</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">countRangeSumRecursive</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">countRangeSumRecursive</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">;</span>

            <span class="c1">// 首先统计下标对的数量</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lower</span><span class="p">)</span> <span class="n">l</span><span class="o">++</span><span class="p">;</span>
                <span class="c1">// r不满足要求</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">)</span> <span class="n">r</span><span class="o">++</span><span class="p">;</span>
                <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">);</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 随后合并两个排序数组</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sorted</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">||</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="p">[</span><span class="n">p2</span><span class="p">])</span> <span class="p">{</span>
                        <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">p1</span><span class="o">++</span><span class="p">];</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">sorted</span><span class="p">[</span><span class="n">p</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">p2</span><span class="o">++</span><span class="p">];</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sorted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span><span class="p">[</span><span class="n">left</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">countRangeSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lower</span><span class="p">,</span> <span class="kt">int</span> <span class="n">upper</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">sum</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">v</span><span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
            <span class="n">sum</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">countRangeSumRecursive</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-13.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-12.html">Leetcode Recorder 12</a>
        </h1>

        <div class="post-info">
          <span class="post-date">15 Nov 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="排序贪心406-queue-reconstruction-by-height">排序+贪心：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. Queue Reconstruction by Height</a></h3>

<p>思路：对于有序数列，可能会存在放入前后的问题。因此进行排序后，可以得到有序数列，对有序数列判断简单操作是否具有全局最优解，若有，就是贪心。</p>

<p>tip：有时候遍历一遍比map更管用，反而用map需要各种条件，限制住了手脚。</p>

<h3 id="桶排序1030-matrix-cells-in-distance-order">桶排序：<a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">1030. Matrix Cells in Distance Order</a></h3>

<p>思路：可以用自定义排序，也可以使用桶排序，因为桶排序的时间复杂度要低。</p>

<p>桶排序的思想就是你需要先明确这些元素最大值最小值的个数，一旦确定，之后再进行分桶。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">dist</span><span class="p">(</span><span class="kt">int</span> <span class="n">r1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">r1</span> <span class="o">-</span> <span class="n">r2</span><span class="p">)</span> <span class="o">+</span> <span class="n">abs</span><span class="p">(</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">allCellsDistOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">R</span><span class="p">,</span> <span class="kt">int</span> <span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxDist</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">R</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">r0</span><span class="p">)</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">C</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">bucket</span><span class="p">(</span><span class="n">maxDist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">c0</span><span class="p">);</span>
                <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">};</span>
                <span class="n">bucket</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxDist</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">it</span> <span class="o">:</span> <span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="数组的双指针-快慢性质283-move-zeroes">数组的双指针-快慢性质：<a href="https://leetcode-cn.com/problems/move-zeroes/">283. Move Zeroes</a></h3>

<p>思路：虽然是简单题，但是用双指针的话，能反映出来数组处理的一些奇妙之处。</p>

<p>可以采用<code class="language-plaintext highlighter-rouge">i,j</code>双指针，其中<code class="language-plaintext highlighter-rouge">j</code>是用来遍历的，<code class="language-plaintext highlighter-rouge">i</code>是用来记录第一个0的位置的。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">moveZeroes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这里面有点动态规划的思想，因为<code class="language-plaintext highlighter-rouge">j</code>是快指针，能保证它处理过的元素没有零，因为初始条件决定的。</p>

<p>这里面的指针有两个性质：</p>

<ul>
  <li>左指针左边均为非零数；</li>
  <li>右指针左边直到左指针处均为零。</li>
</ul>

<h3 id="排序贪心452-minimum-number-of-arrows-to-burst-balloons">排序+贪心：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. Minimum Number of Arrows to Burst Balloons</a></h3>

<p>思路：排序贪心，最重要的就是确定贪心想法，之后根据元素排序确定处理先后关系（这与从前向后处理或从后向前处理有关），从而验证贪心的至少最优解正确性。</p>

<p>和其他合并区间类的题目套路一样, 都是贪心思想, 先排序, 然后遍历检查是否满足合并区间的条件。</p>

<p>比如该题，贪心就是对单个气球而言，尽可能把箭设置在右边，从而能够让其尽可能照顾到所有元素，并可以通过数学归纳与反证法验证贪心关系。</p>

<h3 id="完全二叉树位运算222-count-complete-tree-nodes">完全二叉树+位运算：<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. Count Complete Tree Nodes</a></h3>

<p>思路：对于最大层数为h的完全二叉树，节点个数在$[2^h, 2^{h+1}-1]$之间，可以通过二分查找的方式得到完全二叉树的节点个数。</p>

<p>完全二叉树和二进制也有关系，如果第K个节点位于第h层（root节点在第0层），那么k的二进制包括h+1位，最左边的元素为10000….，之后依次加一。</p>

<p>因此对二进制而言，0可以表示上一个根节点转到了左节点，1可以表示为上一个根节点转到了右节点。因此该节点与上一节点的关系就是$val_{root}«1 + 0/1$.</p>

<h3 id="分治哈希454-4sum-ii">分治+哈希：<a href="https://leetcode-cn.com/problems/4sum-ii/">454. 4Sum II</a></h3>

<p>思路：这里有四组，分开处理，其他的和Two sum的思路是一样的，主要是分治的思想来减少时间复杂度，如果没有分治好，就是$O(n^2-n^3)$的时间复杂度。</p>

<p>教训：不要记题，记题会让你的思路僵化，一开始的路就走错了。</p>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-12.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-11.html">Leetcode Recorder 11</a>
        </h1>

        <div class="post-info">
          <span class="post-date">30 Oct 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="原地快速排序">原地快速排序</h3>

<p>快速排序如果每次都申请数组，用递归来做，是很简单的。找一个pivot，then compare, allocate to an array.</p>

<p>reference:https://magiclen.org/hackerrank-quicksort-in-place/</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="python函数mapzipallany">python函数：map,zip,all,any</h3>

<p><a href="https://leetcode-cn.com/problems/check-if-a-string-can-break-another-string/">Check If a String Can Break Another String</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">checkIfCanBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="n">check</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">all</span><span class="p">,</span> <span class="n">check</span><span class="p">))</span>  
</code></pre></div></div>

<p>判断是否全为正，或者全为负。</p>

<h3 id="模拟插入区间insert-interval">模拟插入区间：<a href="https://leetcode-cn.com/problems/insert-interval/">Insert Interval</a></h3>

<p>思路：用left和right表示插入后区间的变化，用left，right和区间的左右边界的关系判断是否overlap.</p>

<p>对两个区间而言，overlap则意味着除了left&gt;interval[1], right&lt;interval[0]的情况之外，根据overlap的情况不断更新left和right的值。</p>

<p>是一个流动的模拟。</p>

<h3 id="dfs和bfs建图处理字符word-ladder">dfs和bfs建图处理字符：<a href="https://leetcode-cn.com/problems/word-ladder/">Word Ladder</a></h3>

<p>思路：对于string接龙问题，如果只有一个字符的改变，可以创造虚拟节点，从而实现穷举的目的。</p>

<p>通过建图表示字符串之间的联系，将所有的字符串中间加入虚拟节点”string1+*+string2”。</p>

<p>使用BFS遍历图，其中对于已经遍历过的节点，直接用distant[word]进行判断，这在dfs遍历中也很常见，不用再做visited数组进行判断。</p>

<p>建立节点和关系：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">addWord</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wordId</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">wordId</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodeNum</span><span class="o">++</span><span class="p">;</span>
        <span class="n">edge</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">addEdge</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">addWord</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">wordId</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">it</span> <span class="o">:</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
        <span class="n">it</span> <span class="o">=</span> <span class="sc">'*'</span><span class="p">;</span>
        <span class="n">addWord</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">wordId</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
        <span class="n">edge</span><span class="p">[</span><span class="n">id1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">id2</span><span class="p">);</span>
        <span class="n">edge</span><span class="p">[</span><span class="n">id2</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">id1</span><span class="p">);</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后由于完整的distance中，有axbxcxd的形式，所以最后结果res=distance/2+1;</p>

<h3 id="自定义sort函数count-bitsjavacsort-integers-by-the-number-of-1-bits">自定义sort函数/count bits（java/c++）：<a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">Sort Integers by The Number of 1 Bits</a></h3>

<p>思路：该题的思路并不难，关键在于一些小的点怎么用。</p>

<p>count bits api的两个角度.</p>

<p>直接cnt;</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
    <span class="n">cnt</span><span class="o">+=</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">x</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 函数也可以写成：</span>
<span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
    <span class="n">cnt</span><span class="o">+=</span><span class="p">(</span><span class="n">x</span><span class="o">%</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">x</span><span class="o">/=</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>采用递推：bit[i]=bit[i»1]+(i&amp;1)，在该递推中x的范围应该有所限制。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bit</span><span class="p">(</span><span class="mi">10001</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10001</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>还有一个点就是关于java和c++自定义排序的问题，主要关注其中的匿名函数写法。</p>

<p>先看普通函数的写法，关于升序排序。c++</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">numa</span><span class="o">=</span><span class="n">count</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">numb</span><span class="o">=</span><span class="n">count</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">numa</span><span class="o">!=</span><span class="n">numb</span><span class="o">?</span> <span class="n">numa</span><span class="o">&lt;</span><span class="n">numb</span><span class="o">:</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
<span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</code></pre></div></div>

<p>匿名函数：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bit</span><span class="p">(</span><span class="mi">10001</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="n">arr</span><span class="p">){</span>
	<span class="n">bit</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">count</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">arr</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">bit</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&lt;</span><span class="n">bit</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bit</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&gt;</span><span class="n">bit</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="p">;</span>
<span class="p">});</span>
<span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
</code></pre></div></div>

<p>java</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">bit</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10001</span><span class="o">];</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">x:</span> <span class="n">arr</span><span class="o">){</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="n">bit</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">count</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// collections.sort对应的对象是list.</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(){</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">y</span><span class="o">){</span>
        <span class="c1">// 前面的小，后面的大。</span>
        <span class="k">return</span> <span class="n">bit</span><span class="o">[</span><span class="n">x</span><span class="o">]!=</span><span class="n">bit</span><span class="o">[</span><span class="n">y</span><span class="o">]?</span> <span class="n">bit</span><span class="o">[</span><span class="n">x</span><span class="o">]-</span><span class="n">bit</span><span class="o">[</span><span class="n">y</span><span class="o">]:</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">})</span>
</code></pre></div></div>

<p>匿名函数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)-&gt;{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">count</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="o">?</span> <span class="n">o1</span><span class="o">-</span><span class="nl">o2:</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="o">;</span>
<span class="o">})</span>
</code></pre></div></div>

<h3 id="数组处理31-next-permutation">数组处理：<a href="https://leetcode-cn.com/problems/next-permutation/">31. Next Permutation</a></h3>

<p>思路：如果对一个数组而言，找到小于当前的元素，可以直接遍历，从左到右，找到第一个非升序或者非降序的元素，看该元素有何特征。</p>

<h3 id="贪心动态规划514-freedom-trail">贪心/动态规划：<a href="https://leetcode-cn.com/problems/freedom-trail/">514. Freedom Trail</a></h3>

<p>思路：一开始认为应该用贪心来解，但是贪心有本质上的缺点，它和动态规划的区别在于，贪心如果是正确的解，那么它每一步的解应该都能证明是最优解。如果是动态规划的话，前面的解不一定是最优解，我可以用数组来存储当前状态下的解，一步步递进求出全局最优解。</p>

<h3 id="单调栈402-remove-k-digits">单调栈：<a href="https://leetcode-cn.com/problems/remove-k-digits/">402. Remove K Digits</a></h3>

<p>单调栈主要就是维护数组元素的单调关系，最常见的操作就是不断地pop和push，如下：</p>

<p><strong>对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</strong></p>

<ul>
  <li><strong>栈为空</strong></li>
  <li><strong>或者新的栈顶元素不大于当前数字</strong></li>
  <li><strong>或者我们已经删除了k位数字</strong></li>
</ul>

<p>不同于优先队列（堆），这里的栈顶元素：</p>

<ul>
  <li>是序列的前一个元素（pop操作之后的）</li>
  <li>也是前面的元素的最大值/最小值</li>
  <li>保持了序列中的相对前后关系</li>
</ul>

<p>单调栈一般可以保持在O(n)的时间复杂度内。</p>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-11.html">Read More</a>
        </div>
      </article>
      <hr />
      

      
      <nav aria-label="Page navigation">
        <ul class="pagination">
          
            <li><span>&laquo;</span></li>
          

          
            
              <li class="active"><a>1</a></li>
            
          
            
              <li><a href="/pages2/">2</a></li>
            
          
            
              <li><a href="/pages3/">3</a></li>
            
          
            
              <li><a href="/pages4/">4</a></li>
            
          

          
            <li><a href="/pages2/">&raquo;</a></li>
          
        </ul>
      </nav>
      
    </div>

    <div class="col-md-3 main-sidebar">
      <div class="sidebar-content" id="sidebar">
  <div class="author-avatar">
    <img src="/assets/img/author_avatar.jpg" alt="lszero">
  </div>

  <div class="brief-intro">
    <div class="author-name">
      cxcacac
    </div>
    <div class="author-bio">
      Driven by curiosity, more curiosity to the essence in math, physics and computer science.

    </div>
  </div>

  <nav class="site-state">
    <div class="site-state-item">
      <a href="/archives.html">
        <span class="site-state-item-count">20</span>
        <span>Posts</span>
      </a>
    </div>
    <div class="site-state-item">
      <a href="/categories.html">
        <span class="site-state-item-count">5</span>
        <span>Categories</span>
      </a>
    </div>
    <div class="site-state-item">
      <a href="/tags.html">
        <span class="site-state-item-count">6</span>
        <span>Tags</span>
      </a>
    </div>
  </nav>

  <div class="social-icons">
    <a href="https://github.com/cxcacac" class="btn" title="Github" target="_blank"><i class="fa fa-fw fa-github fa-2x" aria-hidden="true"></i></a>
    <!-- <a href="" class="btn" title="Weibo" target="_blank"><i class="fa fa-fw fa-weibo fa-2x" aria-hidden="true"></i></a> -->
    <!-- <a href="" class="btn" title="Zhihu" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse"><strong>知</strong></i></span></a> -->
    <!-- <a href="" class="btn" title="Twitter" target="_blank"><i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i></a> -->
    <!-- <a href="" class="btn" title="Lofter" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse"><strong>L</strong></i></span></a> -->
  </div>

  <hr />

  <nav class="category-list list-group">
    <h3 class="sidebar-title">Categories</h3>
    <ul class="list-group">
    
      <li class="list-group-item">
        <a href="/categories.html#life">life</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#study">study</a>
        <span class="badge">9</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#study,competition">study,competition</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#recorder">recorder</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#competition">competition</a>
        <span class="badge">1</span>
      </li>
    
    </ul>
  </nav>

  <hr />

  <nav class="tags-list">
    <h3 class="sidebar-title">Tags</h3>
    <ul class="list-group">
    
      <li class="list-group-item">
        <a href="/tags.html#Leetcode,"> Leetcode,</a>
        <span class="badge">2</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Sort"> Sort</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Leetcode"> Leetcode</a>
        <span class="badge">9</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#graph"> graph</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#algorithm"> algorithm</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Python"> Python</a>
        <span class="badge">1</span>
      </li>
    
    </ul>
  </nav>

  <hr />

</div>


    </div>
  </div>
</div>



    <footer class="footer">
  <div class="copyright">
      Copyright &copy; <time datetime="2021-04-09T15:13:23+08:00">2021</time> <a href="http://localhost:4000">cxcacac</a> | Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> | Designed by <a href="http://localhost:4000">cxcacac</a>
  </div>
</footer>

    <a href="#top" class="back-to-top">^</a>

<!--      -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="/assets/js/jquery-1.12.4.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/assets/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <!-- TOC -->
    <script src="/assets/js/toc/TOC.js"></script>

    <script>$("#search-form").submit(function(event){
      var query = document.getElementById("search-input").value;
      window.open("http://google.com/search?q=" + query + "%20site:" + "cxcacac.github.io");
    });</script>
  </body>
</html>
