<!DOCTYPE html>
<html lang="en-US">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>
    
      My thoughts &middot; 
    
  </title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="/assets/bootstrap-3.3.7-dist/css/bootstrap.min.css">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
  <!-- My CSS -->
  <link rel="stylesheet" href="/assets/main.css">

  <link rel="shortcut icon" href="/favicon.ico">

<!-- MathJax -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>



  <!-- code highlighting-->
  <link rel="stylesheet" href="/lib/highlight/styles/hybrid.css">
  <script src="/lib/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>hljs.configure({ ignore: ['text'] });</script>
  
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<body>
    <header class="header">
  <!-- Navigation -->
  <nav class="navbar navbar-default .navbar-static-top">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/" style="color:#333">My thoughts</a>
        <p class="navbar-text">Intuitions with enough proficiency are better than theories. </p>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-search">
            <form class="navbar-form navbar-left" role="search" id="search-form">
              <div class="input-group">
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit" style="color:#777">Go!</button>
                  </span>
                  <input type="text" id="search-input" class="form-control" placeholder="Search">
                  
              </div>
            </form>
          </li>
          <li>
            <a href="/archives.html">Archives</a>
          </li>
          <li>
            <a href="/categories.html">Categories</a>
          </li>
          <li>
            <a href="/tags.html">Tags</a>
          </li>
          <li>
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
</header>

  
    <div class="container">
  <div class="row-fluid main">
    <div class="col-md-9 content main-posts-preview">
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-10.html">Leetcode Recorder 10</a>
        </h1>

        <div class="post-info">
          <span class="post-date">14 Sep 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="morris遍历算法">Morris遍历算法</h3>

<p>比如中序遍历：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">predecessor</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span>
                <span class="n">predecessor</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">predecessor</span> <span class="o">=</span> <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
                
                <span class="c1">// 让 predecessor 的右指针指向 root，继续遍历左子树</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 说明左子树已经访问完了，我们需要断开链接</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                    <span class="n">predecessor</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                    <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 如果没有左孩子，则直接访问右孩子</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="并查集有向图">并查集+有向图</h3>

<h4 id="redundant-connection-ii"><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">Redundant Connection II</a></h4>

<p>思路：主要是有向图的话，有两种类型的边要移除，这是需要考虑清楚的。</p>

<p>​    // 不一定有环出现，也不一定有冲突出现，但只能有一条边被移除而恢复正常，所以冲突的边和环边有一个节点是重合的。</p>

<p>​    // 另外，冲突的边不可能出现两个不同的节点上，否则不满足只移除一条边的限制。</p>

<p>​    // 这里是两类，所以一定要判断以下，是冲突还是环，而不是放在一个unionfind里，对无向图是有用的，无向图是只要连接就会归到同一个派别。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">UnionFind</span> <span class="p">{</span>
    <span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ancestor</span><span class="p">;</span>

    <span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ancestor</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ancestor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">==</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">?</span> <span class="n">index</span> <span class="o">:</span> <span class="n">ancestor</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">ancestor</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ancestor</span><span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findRedundantDirectedConnection</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 特殊之处在于图是directed graph.</span>
        <span class="kt">int</span> <span class="n">cntsize</span> <span class="o">=</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">UnionFind</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">cntsize</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cntsize</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cntsize</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">conflict</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cntsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">){</span>
                <span class="n">conflict</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">uf</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)){</span>
                    <span class="n">cycle</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="n">uf</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">conflict</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">edges</span><span class="p">[</span><span class="n">cycle</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">cycle</span><span class="p">][</span><span class="mi">1</span><span class="p">]};</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cycle</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">edges</span><span class="p">[</span><span class="n">conflict</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="n">conflict</span><span class="p">][</span><span class="mi">1</span><span class="p">]};</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="c1">// 如果存在cycle，最后要移除的边不一定是最后一条形成环的边，因为与其他节点的关系未知，而是冲突边(因为只能保留一条冲突边。)</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">parent</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">conflict</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">edges</span><span class="p">[</span><span class="n">conflict</span><span class="p">][</span><span class="mi">1</span><span class="p">]};</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="动态规划binary-tree-cameras">动态规划：<a href="https://leetcode-cn.com/problems/binary-tree-cameras/">Binary Tree Cameras</a></h3>

<p>思路：当一个节点的状态与父节点和子节点（在数组中就是前面的状态和后面的状态会同时作用于当前的状态），该节点的状态一般有三个，其一是选择1，其二是被子节点的1影响，其三是被父节点的1影响，子节点没有作用。</p>

<h3 id="链表-linked-list-cycle-ii">链表：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/"> Linked List Cycle II</a></h3>

<p>思路：</p>

<ul>
  <li>
    <p>—-a(初始点) —-b(相遇点)，fast走的路程(2a+2b)-slow走的路程(a+b)=a+b，所以再走a可以到初始点。</p>
  </li>
  <li>现在的slow的位置，和指针head的位置，同时走，可以在初始点相遇。</li>
  <li>（重要）在链表中，长度是通过指针的相遇（快慢指针）表示的，而不是一个特定的数。</li>
</ul>

<h3 id="链表populating-next-right-pointers-in-each-node-ii">链表：<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">Populating Next Right Pointers in Each Node II</a></h3>

<p>思路：</p>

<p>递归是从右侧往左递归，逐步建立连接，寻找下一个节点的过程也是使用递归，这个DFS和BFS一样写的漂亮。</p>

<p>同时，从题目中也可以看到，c++和python类的构造函数逻辑不太相同，一个是重写函数，一个是设置构造函数的默认值。</p>

<p>两种方法同样都是对子结点进行处理，而不是对当前节点进行处理：</p>

<p>DFS：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">connect</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// DFS并不是分治的思想，因为需要连接不同树的节点。</span>
        <span class="c1">// BFS很简单，最主要的是constant extra space.</span>
        <span class="c1">// 可以从右侧进行BFS建立连接，有点dp的意味</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">){</span>
            <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 函数名字写的不好，不应该是next，而应该是getnode</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">next</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="c1">// if(root-&gt;next) return next(root-&gt;next);</span>
        <span class="c1">// return NULL;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在链表中，存元素可以在这里做一个head节点，然后用head.next来找到元素，处理方法是很高明的。</p>

<p>BFS:</p>

<pre><code class="language-PYTHON">class Solution:
    def connect(self, root: 'Node') -&gt; 'Node':
        # 在当前层将下一层的节点连接，高
        # 建立了单向连接，所以只能从左到右
        left_most = root
        while left_most:
            cur = left_most
            # cur再上一层，pre在下一层
            head = pre = Node()
            while cur:
                if cur.left:
                    pre.next = cur.left
                    pre = pre.next
                if cur.right:
                    pre.next = cur.right
                    pre = pre.next
                cur = cur.next
            # 怎么换层？
            left_most = head.next
        return root
</code></pre>

<h3 id="二分法koko-eating-bananas">二分法：<a href="https://leetcode-cn.com/problems/koko-eating-bananas/">Koko Eating Bananas</a></h3>

<p>Note：int mi = lo + (hi - lo) / 2; 在lo和hi都比较大的时候，会导致越界的问题。</p>

<p>这里面还有划分派别的问题：</p>

<p>如果要给1~k的元素都划分到第1个派别，采用式子$n=(m-1)/k+1$，解决这种时间的问题是最好用的，因为一个小时就算没用完也使用了。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">minEatingSpeed</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">piles</span><span class="p">,</span> <span class="kt">int</span> <span class="n">H</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mi</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">possible</span><span class="p">(</span><span class="n">piles</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">mi</span><span class="p">))</span>
                <span class="n">lo</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">mi</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">lo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">possible</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">piles</span><span class="p">,</span> <span class="kt">int</span> <span class="n">H</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">:</span> <span class="n">piles</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">+=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="n">H</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="动态规划lcp-19-秋叶收藏集">动态规划：<a href="https://leetcode-cn.com/problems/UlBDOe/">LCP 19. 秋叶收藏集</a></h3>

<p>思路：动态规划还是最重要的两个问题：</p>

<ul>
  <li>状态的表示，用什么来表示一个状态，dp[i][j]表示什么意思？</li>
  <li>状态的转移关系，是如何利用子状态建立起来当前状态的？</li>
</ul>

<p>在这个题中，dp[i][j]可以表示为当前的位置为i处于j状态时的最小个数，j可以分为三个状态，即前面的红，后面的红，中间的黄，是按照顺序划分的，并不是按照种类划分的。</p>

        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-10.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/leetcode-recorder-09.html">Leetcode Recorder 09</a>
        </h1>

        <div class="post-info">
          <span class="post-date">01 Sep 2020</span>
          
          
        </div>

        <div class="post-excerpt">
          <h3 id="动态规划二分">动态规划+二分</h3>

<p>三道题：</p>

<p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a>、<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a>。</p>

<p><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. Maximum Length of Pair Chain</a></p>

<h3 id="robin-karp-manacher-kmp算法">Robin-karp, manacher, KMP算法</h3>

<p>其中kmp的模板可以看下面的：</p>

<p>https://leetcode-cn.com/problems/shortest-palindrome/solution/zui-duan-hui-wen-chuan-by-leetcode-solution/</p>

<p>关于c++，这种写法：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ViolentMatch</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
 
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sLen</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pLen</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
		<span class="p">{</span>
			<span class="c1">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    </span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="c1">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    </span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">pLen</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>kmp的next数组求法：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">function</span> <span class="nf">getNext</span><span class="p">(</span><span class="nv">$word</span><span class="p">)</span><span class="o">:</span> <span class="k">array</span>
<span class="p">{</span>
    <span class="nv">$next</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="nv">$len</span> <span class="o">=</span> <span class="nb">strlen</span><span class="p">(</span><span class="nv">$word</span><span class="p">);</span>
    <span class="nv">$k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nv">$j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nv">$j</span> <span class="o">&lt;</span> <span class="nv">$len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$k</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nv">$word</span><span class="p">[</span><span class="nv">$j</span><span class="p">]</span> <span class="o">==</span> <span class="nv">$word</span><span class="p">[</span><span class="nv">$k</span><span class="p">])</span> <span class="p">{</span>
            <span class="nv">$next</span><span class="p">[</span><span class="o">++</span><span class="nv">$j</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="nv">$k</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$k</span> <span class="o">=</span> <span class="nv">$next</span><span class="p">[</span><span class="nv">$k</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="k">return</span> <span class="nv">$next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="有限状态自动机">有限状态自动机</h3>

<p>确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：</p>

<p>有一个特殊的状态，被称作「初始状态」。
还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。</p>

<p>如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。</p>

<p>https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</p>

<p>这道题后面的有限自动学习机的代码很有意思，可以看一下。</p>

<h3 id="顺序与派别">顺序与派别</h3>

<p>比如1，2，3，4，5，6，从一开始。 其中:</p>

<ul>
  <li>1，2属于派系1.</li>
  <li>3，4属于派系2</li>
  <li>按照顺序划分，假设每个派系有k个元素，如何判断该元素属于什么派系？</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--n;
res = n/k + 1;
</code></pre></div></div>

<h3 id="反转链表">反转链表</h3>

<p>pre代表前面的链的第一个节点，head代表后面的链的第一个节点，通过训练加一个head节点到pre节点前面，并且重新赋值。</p>

<p>最后pre节点为头结点的链为反转之后的链。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ListNode</span><span class="o">*</span> <span class="n">pre</span><span class="o">=</span><span class="nb">nullptr</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">head</span><span class="p">){</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="n">head</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pre</span><span class="p">;</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="位运算与幂运算">位运算与幂运算</h3>

<p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方 LCOF</a></p>

<p>这里面还有一个命题是关于int32的范围。</p>

<p>-2147483648这个指数也很有意思呢，如果为了用移位取代除法来加速，负数是用补码表示的，补码的除法逻辑又不能用移位来解决…就需要取n的绝对值…因为int的取值范围是-2147483648到2147483647…所以java的Math.abs(n)在这个时候返回的还是-2147483648</p>

<p>Java 代码中 int32 变量n∈[−2147483648,2147483647] ，因此当 n = -2147483648 时执行 n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</p>

<h3 id="tips">tips:</h3>

<h4 id="c定义堆中的比较规则">c++定义堆中的比较规则</h4>

<p>优先队列的使用方式。</p>

<p>priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int», decltype(&amp;cmp)&gt; q(cmp);</p>

<h4 id="java中关于堆的处理方式">java中关于堆的处理方式：</h4>

<p>其中包括priorityqueue的poll与offer，map的遍历。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">topKFrequent</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">occurrences</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">occurrences</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">occurrences</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">m</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">n</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">occurrences</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(),</span> <span class="n">count</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">num</span><span class="o">,</span> <span class="n">count</span><span class="o">});</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ret</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ret</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">()[</span><span class="mi">0</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/leetcode-recorder-09.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/study/leetcode-recorder-09.html">leetcode algorithm-09</a>
        </h1>

        <div class="post-info">
          <span class="post-date">01 Jul 2020</span>
           | 
            <span class="fa fa-folder-open" aria-hidden="true">
            
              <a class="post-categories" href="/categories.html#study">study</a>
            
            </span>
          
           | 
            <span class="fa fa-tag" aria-hidden="true">
            
              <a class="post-tags" href="/tags.html#Leetcode">Leetcode</a>
            
            </span>
          
        </div>

        <div class="post-excerpt">
          <h1 id="刷题记录-0701">刷题记录-0701</h1>

<h3 id="博弈游戏动态规划stone-game">博弈游戏+动态规划：<a href="https://leetcode-cn.com/problems/stone-game/">Stone Game</a></h3>

<p>思路：是在二维 dp 的基础上使用元组分别存储两个人的博弈结果。动态规划的思路，其实本质上就是强化学习的思路，就是属于当前状态+选择过程。</p>

<p>tips：一般情况下，动态规划都可以写成递归，所以可以先用递归的方式想问题，找到状态之间的转移关系。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">stoneGame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">piles</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># 如果每次每个人都做出最优的选择，Alex还是赢，说明Alex must win the game
</span>        <span class="c1"># 因此在该问题中，每个人的策略都是相同的，可以用一个dp数组表示。
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">piles</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="n">piles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="c1"># 根据状态转移关系，为了满足从最小子状态建立的流程，需要从base的情况考虑dp数组如何遍历。
</span>        <span class="c1"># 在下面的遍历中，i表示包含的元素个数-1，j表示起始位置，dp[s][e]中s,e表示开始的位置和最后的位置。
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">piles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">],</span> <span class="n">piles</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>                
</code></pre></div></div>

<h3 id="数组元素和indexfirst-missing-positive">数组元素和index：<a href="https://leetcode-cn.com/problems/first-missing-positive/">First Missing Positive</a></h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">firstMissingPositive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="c1"># 数组的值用做index来节省时间和空间。
</span>            <span class="c1"># 要注意利用被覆盖的值，所以这里是需要swap位置的。
</span>            <span class="c1"># 如果要swap的话，必须要用while循环来利用当前swap到的元素，否则还是没有利用到被覆盖的值。
</span>            <span class="c1"># 为了避免无限循环，有两个限制条件:
</span>            <span class="c1"># (1)当元素没法利用的时候需要停止. 
</span>            <span class="c1"># (2)当元素正好的定位到当前位置，即元素和它要对应的元素位置正好是相等的。
</span>            <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">temp</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">temp</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="动态规划longest-valid-parentheses">动态规划：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">Longest Valid Parentheses</a></h3>

<p>思路：dp[i]表示以当前字符为结束的有效字符串长度(注意不是有效括号个数)。</p>

<p>其中这个问题有个隐藏的约束：即有效字符串的内部必须全部都是有效的括号，不可以单单出来一个字符。</p>

<p><strong>Summary about State：</strong></p>

<p>还有一类问题，状态设置是以当前字符或者当前下标作为边界的状态，在这里是有效字符串的长度。</p>

<p>差别就是一个必须包含最后的字符作为结束字符，一个不需要包含最后的字符。</p>

<p>上面两种不同的状态设置方式,主要有两个差别:</p>

<ul>
  <li>
    <p>最后做O(n)的max(dp)的运算,或者直接输出dp[-1]</p>
  </li>
  <li>
    <p>以当前index作为边界的状态设置少了一个必须包含当前元素的约束，需要考虑多种情况.</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">longestValidParentheses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 有效括号字符串,内部必须全部都是有效括号字符串.
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">')'</span><span class="p">:</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pre</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">pre</span><span class="p">]</span> <span class="o">==</span> <span class="s">'('</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
                    <span class="k">if</span> <span class="n">pre</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">pre</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span> 
</code></pre></div></div>

<h3 id="动态规划count-numbers-with-unique-digits">动态规划：<a href="https://leetcode-cn.com/problems/count-numbers-with-unique-digits/">Count Numbers with Unique Digits</a></h3>

<p>思路：这里的状态选择的位数，即dp[i]代表i位数的所有情况。</p>

<p>有了状态的选择之后，就可以状态之间的转移方程：<code class="language-plaintext highlighter-rouge">dp[i] = dp[i-1] + (dp[i-1]-dp[i-2])*(10-(i-1))</code></p>

<p>其中，<code class="language-plaintext highlighter-rouge">dp[i-1]-dp[i-2]</code>是只考虑位数为<code class="language-plaintext highlighter-rouge">i-1</code>的情况，然后和最后一位的个数相乘，是一种排列组合。</p>

<p>由于<code class="language-plaintext highlighter-rouge">i</code>只依赖于<code class="language-plaintext highlighter-rouge">i-1</code>和<code class="language-plaintext highlighter-rouge">i-2</code>，所以这里可以采用节省内存的dp。</p>

<p>NOTE: 第一位为0不贡献位数，仍然是<code class="language-plaintext highlighter-rouge">i-1</code></p>

<p><strong>Summary：</strong></p>

<p>动态规划其实就两个步骤：</p>

<ul>
  <li>状态的选择，<code class="language-plaintext highlighter-rouge">dp[i]</code>代表什么，<code class="language-plaintext highlighter-rouge">dp[i][j]...</code>代表什么状态，要有代表性，可以设置多个状态数组。</li>
  <li>状态的转移，不同状态之间的关系是什么，或者不同状态数组之间的转移是什么</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countNumbersWithUniqueDigits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">10</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># b - a 是一种推导结果，只考虑i-1位的情况，最后一位的情况要看现在总共有多少位数。
</span>        <span class="c1"># 0不贡献位数。
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">10</span><span class="o">-</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span>
</code></pre></div></div>

<h3 id="动态规划wildcard-matching">动态规划：<a href="https://leetcode-cn.com/problems/wildcard-matching/">Wildcard Matching</a></h3>

<p><strong>summary：</strong>动态规划的状态延续性，在某种程度上是一种承接，后一个状态可以由前一个状态修改后获得，也可以承接前一个状态，在这道题中，承接性做的好，省去了很多麻烦。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># classic dynamic programming
</span>        <span class="c1"># is it possible to have consecutive symbol "**"??
</span>        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"*"</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"?"</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">:</span>
                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># empty sequence
</span>    
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/study/leetcode-recorder-09.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/competition/As-a-rookie-firstAK.html">record of my first AK</a>
        </h1>

        <div class="post-info">
          <span class="post-date">28 Jun 2020</span>
           | 
            <span class="fa fa-folder-open" aria-hidden="true">
            
              <a class="post-categories" href="/categories.html#competition">competition</a>
            
            </span>
          
           | 
            <span class="fa fa-tag" aria-hidden="true">
            
              <a class="post-tags" href="/tags.html#Leetcode">Leetcode</a>
            
            </span>
          
        </div>

        <div class="post-excerpt">
          <p><img src="\image\image-20200630103645135.png" alt="image-20200630103645135" /></p>

<p><img src="\image\image-20200630103656455.png" alt="image-20200630103656455" /></p>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/competition/As-a-rookie-firstAK.html">Read More</a>
        </div>
      </article>
      <hr />
      
      <article class="post-preview">
        <h1 class="post-title">
          <a href="/study/leetcode-recorder-08.html">leetcode algorithm-08</a>
        </h1>

        <div class="post-info">
          <span class="post-date">24 Jun 2020</span>
           | 
            <span class="fa fa-folder-open" aria-hidden="true">
            
              <a class="post-categories" href="/categories.html#study">study</a>
            
            </span>
          
           | 
            <span class="fa fa-tag" aria-hidden="true">
            
              <a class="post-tags" href="/tags.html#Leetcode">Leetcode</a>
            
            </span>
          
        </div>

        <div class="post-excerpt">
          <h1 id="刷题记录-06-24">刷题记录-06-24</h1>

<h3 id="双指针remove-duplicates-from-sorted-array-ii">双指针：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">Remove Duplicates from Sorted Array II</a></h3>

<p>思路：利用双指针，需要判断一下该元素是否与两个位置之前的数组元素是否相等，如果不相等，则需要赋到对应的指针所在的位置。代码非常精妙。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">removeDuplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># sorted order.
</span>        <span class="c1"># if two number are arranged, can neglect the element by comparisions.
</span>        <span class="c1"># two pointers
</span>        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> 
        <span class="k">return</span> <span class="n">i</span>
</code></pre></div></div>

<h3 id="动态规划regular-expression-matching">动态规划：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">Regular Expression Matching</a></h3>

<p>思路：二维数组的状态转移方程：$dp[i][j] = f(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])$，只不过在这个题中考虑的状态比较复杂和多一点而已。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># 两字符递进匹配，dp[i-1][j-1],  dp[i-1][j], dp[i][j-1]
</span>                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span> <span class="ow">or</span> 
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">)</span> <span class="ow">or</span> 
                <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span><span class="s">'*'</span> <span class="ow">and</span> <span class="p">((</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="ow">or</span> 
                <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">'.'</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">'*'</span><span class="p">)))</span> 
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="字符串匹配-pattern-matching-lcci"><strong>字符串匹配：</strong><a href="https://leetcode-cn.com/problems/pattern-matching-lcci/"> Pattern Matching LCCI</a></h3>

<p>这个做法，整个思路流程非常的通畅，从特殊情况简单处理，到复杂情况复杂处理。</p>

<p>C++:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">bool</span> <span class="n">patternMatching</span><span class="p">(</span><span class="n">string</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">string</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// From simple to complex</span>
        <span class="c1">// consider one of the Strings equals to null.</span>
        <span class="c1">// merge all the possibilities to get a simpler form.</span>
        <span class="c1">// note the special</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pattern</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">m</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span> <span class="n">pattern</span><span class="p">)</span> <span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="sc">'a'</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// if(helper(value,cnt[0]) || helper(value, cnt[1])) return true;  </span>
        <span class="c1">// 上面这个代码如果统一的话，没有截止等于0的情况，后面取余数会有问题。</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">helper</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">helper</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">// In the following steps, a and b can not equals to null.</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">lena</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lena</span><span class="o">*</span><span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">lena</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">((</span><span class="n">m</span><span class="o">-</span><span class="n">lena</span><span class="o">*</span><span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">%</span><span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">lenb</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="n">lena</span><span class="o">*</span><span class="n">cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">lena</span><span class="p">,</span> <span class="n">lenb</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">helper</span><span class="p">(</span><span class="n">string</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
        <span class="c1">// 判断是否能切分k次，且全部相等。</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">m</span><span class="o">/</span><span class="n">k</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">len</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">len</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">check</span><span class="p">(</span><span class="n">string</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">string</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lena</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lenb</span><span class="p">){</span>
        <span class="n">string</span> <span class="n">ps</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">""</span><span class="p">,</span><span class="s">""</span><span class="p">};</span> <span class="c1">// double quotations</span>
        <span class="c1">// c++好像字符串不能直接相等。</span>
        <span class="c1">// j是该模式起始的位置。</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'a'</span><span class="p">){</span>
                <span class="c1">// 如果没有被赋值，首先赋值，之后再进行比较。</span>
                <span class="k">if</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">""</span><span class="p">)</span> <span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">lena</span><span class="p">);</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">lena</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">lena</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">""</span><span class="p">)</span> <span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">lenb</span><span class="p">);</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">lenb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="n">lenb</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="动态规划递归转换unique-binary-search-trees-ii">动态规划/递归转换：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">Unique Binary Search Trees II</a></h3>

<p>思路：递归比较容易，只需要考虑主问题和次问题之间是怎么连接的，从上到下考虑即可。动态规划需要从下到上，看最优的子状态是如何形成最终的状态的，注重于状态之间的转换关系。一般情况下两者都是可以转换的。只要建立好子结构就可以。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">generateTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="c1"># recursion，main section -&gt; smaller section with same function.
</span>        <span class="c1"># dynamic pogramming -&gt; relations between consecutive states, several states -&gt; one state.
</span>        <span class="c1"># This is a binary search tree.
</span>        <span class="c1"># method 1, recursion.
</span>        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
            <span class="c1"># e is exclusive, s is inclusive 
</span>            <span class="c1"># return all the possibilities under the root
</span>            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">helper</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">left</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">temp</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">l</span> 
                        <span class="n">temp</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> 
            <span class="k">return</span> <span class="n">res</span> 
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="位运算add-binary">位运算：<a href="https://leetcode-cn.com/problems/add-binary/">Add Binary</a></h3>

<p>思路：主要是对carry和加和的处理，carry加到num数上，相当于移位之后多做一层num累加。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">addBinary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">y</span><span class="p">:</span>
            <span class="c1"># 直到carry没有为止，carry相当于进行移位累加。
</span>            <span class="n">answer</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">answer</span><span class="p">,</span> <span class="n">carry</span>
        <span class="k">return</span> <span class="nb">bin</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
    	<span class="c1"># 需要把0b去掉。
</span></code></pre></div></div>

<h3 id="动态规划counting-bits">动态规划：<a href="https://leetcode-cn.com/problems/counting-bits/">Counting Bits</a></h3>

<p>思路：在动态规划中，可以分类建立子状态的关系，这道题就是把奇数和偶数分开，奇数和偶数之间的差别，奇数之间差1，偶数之间差1，建立联系即可。</p>

<p>所以关键就是这里并非是连续的状态转换关系，而是差了个2.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">countBits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="c1"># 1,10,11,100,101....
</span>        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># 找到奇偶之间的关系，奇数比之前的偶数+1，偶数比之前的num&gt;&gt;1的数一样的。
</span>        <span class="c1"># 关系可以是分开创建的，即奇数和奇数建立联系，偶数和偶数建立联系。
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">dp</span>
</code></pre></div></div>


        </div>

        <div class="post-readmore">
          <a class="read-more" href="/study/leetcode-recorder-08.html">Read More</a>
        </div>
      </article>
      <hr />
      

      
      <nav aria-label="Page navigation">
        <ul class="pagination">
          
            <li><a href="/">&laquo;</a></li>
          

          
            
              <li><a href="/">1</a>
              </li>
            
          
            
              <li class="active"><a>2</a></li>
            
          
            
              <li><a href="/pages3/">3</a></li>
            
          
            
              <li><a href="/pages4/">4</a></li>
            
          

          
            <li><a href="/pages3/">&raquo;</a></li>
          
        </ul>
      </nav>
      
    </div>

    <div class="col-md-3 main-sidebar">
      <div class="sidebar-content" id="sidebar">
  <div class="author-avatar">
    <img src="/assets/img/author_avatar.jpg" alt="lszero">
  </div>

  <div class="brief-intro">
    <div class="author-name">
      cxcacac
    </div>
    <div class="author-bio">
      Driven by curiosity, more curiosity to the essence in math, physics and computer science.

    </div>
  </div>

  <nav class="site-state">
    <div class="site-state-item">
      <a href="/archives.html">
        <span class="site-state-item-count">20</span>
        <span>Posts</span>
      </a>
    </div>
    <div class="site-state-item">
      <a href="/categories.html">
        <span class="site-state-item-count">5</span>
        <span>Categories</span>
      </a>
    </div>
    <div class="site-state-item">
      <a href="/tags.html">
        <span class="site-state-item-count">6</span>
        <span>Tags</span>
      </a>
    </div>
  </nav>

  <div class="social-icons">
    <a href="https://github.com/cxcacac" class="btn" title="Github" target="_blank"><i class="fa fa-fw fa-github fa-2x" aria-hidden="true"></i></a>
    <!-- <a href="" class="btn" title="Weibo" target="_blank"><i class="fa fa-fw fa-weibo fa-2x" aria-hidden="true"></i></a> -->
    <!-- <a href="" class="btn" title="Zhihu" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse"><strong>知</strong></i></span></a> -->
    <!-- <a href="" class="btn" title="Twitter" target="_blank"><i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i></a> -->
    <!-- <a href="" class="btn" title="Lofter" target="_blank"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse"><strong>L</strong></i></span></a> -->
  </div>

  <hr />

  <nav class="category-list list-group">
    <h3 class="sidebar-title">Categories</h3>
    <ul class="list-group">
    
      <li class="list-group-item">
        <a href="/categories.html#life">life</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#study">study</a>
        <span class="badge">9</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#study,competition">study,competition</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#recorder">recorder</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/categories.html#competition">competition</a>
        <span class="badge">1</span>
      </li>
    
    </ul>
  </nav>

  <hr />

  <nav class="tags-list">
    <h3 class="sidebar-title">Tags</h3>
    <ul class="list-group">
    
      <li class="list-group-item">
        <a href="/tags.html#Leetcode,"> Leetcode,</a>
        <span class="badge">2</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Sort"> Sort</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Leetcode"> Leetcode</a>
        <span class="badge">9</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#graph"> graph</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#algorithm"> algorithm</a>
        <span class="badge">1</span>
      </li>
    
      <li class="list-group-item">
        <a href="/tags.html#Python"> Python</a>
        <span class="badge">1</span>
      </li>
    
    </ul>
  </nav>

  <hr />

</div>


    </div>
  </div>
</div>



    <footer class="footer">
  <div class="copyright">
      Copyright &copy; <time datetime="2021-04-09T15:13:23+08:00">2021</time> <a href="http://localhost:4000">cxcacac</a> | Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> | Designed by <a href="http://localhost:4000">cxcacac</a>
  </div>
</footer>

    <a href="#top" class="back-to-top">^</a>

<!--      -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="/assets/js/jquery-1.12.4.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/assets/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <!-- TOC -->
    <script src="/assets/js/toc/TOC.js"></script>

    <script>$("#search-form").submit(function(event){
      var query = document.getElementById("search-input").value;
      window.open("http://google.com/search?q=" + query + "%20site:" + "cxcacac.github.io");
    });</script>
  </body>
</html>
