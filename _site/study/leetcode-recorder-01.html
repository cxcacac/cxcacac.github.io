<!DOCTYPE html>
<html lang="en-US">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <title>
    
      leetcode algorithm-01 &middot; My thoughts
    
  </title>

  <!-- Bootstrap -->
  <link rel="stylesheet" href="/assets/bootstrap-3.3.7-dist/css/bootstrap.min.css">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
  <!-- My CSS -->
  <link rel="stylesheet" href="/assets/main.css">

  <link rel="shortcut icon" href="/favicon.ico">

  <!-- MathJax -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: {
          autoNumber: "AMS"
        }
      },
      tex2jax: {
        inlineMath: [ ['$','$'] ],
        displayMath: [ ['$$','$$'] ],
        processEscapes: true,
      }
    });
  </script>
  

  <!-- code highlighting-->
  <link rel="stylesheet" href="/lib/highlight/styles/hybrid.css">
  <script src="/lib/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>hljs.configure({ ignore: ['text'] });</script>
  
  <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<body>
    <header class="header">
  <!-- Navigation -->
  <nav class="navbar navbar-default .navbar-static-top">
    <div class="container">
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/" style="color:#333">My thoughts</a>
        <p class="navbar-text">Intuitions with enough proficiency are better than theories. </p>
      </div>

      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-search">
            <form class="navbar-form navbar-left" role="search" id="search-form">
              <div class="input-group">
                  <span class="input-group-btn">
                    <button class="btn btn-default" type="submit" style="color:#777">Go!</button>
                  </span>
                  <input type="text" id="search-input" class="form-control" placeholder="Search">
                  
              </div>
            </form>
          </li>
          <li>
            <a href="/archives.html">Archives</a>
          </li>
          <li>
            <a href="/categories.html">Categories</a>
          </li>
          <li>
            <a href="/tags.html">Tags</a>
          </li>
          <li>
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
</header>

  
    <div class="container">
  <div class="row-fluid main">
    <div class="col-md-9 content">
      <article class="post">
        <h1 class="post-title">leetcode algorithm-01</h1>

        <div class="post-info">
          <span class="post-date">06 May 2020</span>
           | 
            <span class="fa fa-folder-open" aria-hidden="true">
            
              <a class="post-categories" href="/categories.html#study">study</a>
            
            </span>
          
           | 
            <span class="fa fa-tag" aria-hidden="true">
            
              <a class="post-tags" href="/tags.html#Leetcode,">Leetcode,</a>
            
              <a class="post-tags" href="/tags.html#Sort">Sort</a>
            
            </span>
          
        </div>

        <hr>
        <div class="post-content">
          <h2 id="-20200506">-2020/05/06</h2>

<p><strong>题目1：<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets">最低票价</a></strong></p>

<p>思路：动态规划，不同的是该题从后往前建立最优解。</p>

<p>动态规划的题思路：</p>

<ul>
  <li>确定$dp[i][j][k]…$代表的含义，包括$i,j,k$代表的index是哪些部分。</li>
  <li>最小的结构是什么，该题中的最小结构是最后的部分，所以是从最小结构开始建立。</li>
  <li>状态转移方程是什么。该题是$dp[i] = min(cost[0]+dp[i+1], cost[1]+dp[i+7], cost[2]+dp[i+30])$。</li>
</ul>

<p><strong>题目2：<a href="https://leetcode-cn.com/problems/sort-an-array/">排序数组</a></strong></p>

<p>思路：经典排序</p>

<p>主要对几种排序的思路进行梳理，只是初步的一个分析，后续会再次修改。</p>

<p>另外，对Bogo排序，珠排序，睡眠排序进行整理。</p>

<p>注：只有比较排序，才会有$\Omega(n \log n)$的限制。</p>

<ul>
  <li>
    <p><strong>选择排序（Selection Sort）</strong></p>

    <p>思路：暴力解法。设置最小值，遍历比较，换位置，时间复杂度$O(n^2)$</p>

    <p>python:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
              <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                  <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>插入排序(Insertion Sort)</strong></p>

    <p>思路：从前往后逐渐排序，选取未排序的子序列的第一个元素移动插入到排序好的子序列中合适的位置。时间复杂度$O(n^2)$</p>

    <p>python:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
          <span class="k">while</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
              <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
              <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>冒泡排序（Bubble Sort）</strong></p>

    <p>思路：从后往前逐渐排序，大元素沉到数组的最后面。时间复杂度$O(n^2)$</p>

    <p>python：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="c1"># i表示多个元素bubble，不表示位置。
</span>      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
          <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
              <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                  <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>归并排序（Merge Sort）</strong></p>

    <p>思路：采用分治法的思路，将序列分为最小子序列，然后一层层合并两个有序数组。时间复杂度$O(n\log n)$。注意分治法需要确定最小子单元的终止条件，例如left&lt;right，或者len(nums)==1.</p>

    <p>python</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">nums</span>
      <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
      <span class="n">left</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
      <span class="n">right</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
      <span class="c1"># 取切片效率低,也可以传入两个两个参数，将left&lt;right做为终止判定条件。
</span>      <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">):</span>
      <span class="c1"># 利用双指针法进行合并
</span>      <span class="n">res</span> <span class="o">=</span><span class="p">[]</span>
      <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
      <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
          <span class="k">if</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
          <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
              <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
              <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">res</span> <span class="o">+=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
      <span class="n">res</span> <span class="o">+=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
      <span class="k">return</span> <span class="n">res</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>快速排序（Quick Sort）</strong></p>

    <p>思路：将数组分为两个部分，分别排序，最后组合。从数组中选取一个基准数（pivot），大于和小于pivot的数组分为两个部分（Partition），然后递归一直partition后合并，有点像paired-comparison。该算法时间复杂度为$O(n \log n)$。</p>

    <p>python:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">nums</span>
      <span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
      <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
      <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="n">pivot</span><span class="p">]</span>
      <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">pivot</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="n">middle</span><span class="o">+</span><span class="n">quicksort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>希尔排序（Shell sort）</strong></p>

    <p>思路：针对插入排序只能将数据和邻位来比较移动一位的低效方式，希尔排序提高了移动的步长。该算法选择一个合适的增量序列，增量序列的最后一个元素为1，就是普通的插入排序。但是与普通的插入排序相比，步长较大的排序会做大部分的工作，从而降低时间复杂度。希尔排序的时间复杂度和增量序列的选择有关。可以从$O(n^{1.3})-O(n^2)$</p>

    <p>python：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
      <span class="n">gap</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="mi">2</span>
      <span class="k">while</span> <span class="n">gap</span><span class="p">:</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gap</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
              <span class="k">while</span> <span class="n">i</span><span class="o">-</span><span class="n">gap</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">gap</span><span class="p">]</span><span class="o">&gt;</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
              <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">gap</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span>
                  <span class="n">i</span> <span class="o">-=</span> <span class="n">gap</span>
      <span class="n">gap</span><span class="o">//=</span><span class="mi">2</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>堆排序（Heap Sort）</strong></p>

    <p>思路：依照数组建堆，并把数组转换成最大堆（Max-Heap Heap），重复从最大堆中取出数值最大的结点。时间复杂度为$O(n \log n)$，建堆后主要分为以下几个步骤：</p>

    <p>（1）最大堆调整，使子节点永远小于父节点从而建立最大堆</p>

    <p>（2）交换堆顶和堆底元素，移出根节点，之后继续进行最大堆调整。</p>

    <p>注：对堆节点的访问，在数组起始位置为0时，满足</p>

    <ul>
      <li>
        <p>父节点$i \rightarrow 2i+1（2i+2）$左（右）子节点。</p>
      </li>
      <li>
        <p>子节点$i \rightarrow \lfloor (i-1)/2 \rfloor$父节点。</p>
      </li>
    </ul>

    <p>python：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">sift_down</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>
          <span class="c1"># 对start元素在end节点之前找到合适的位置。
</span>          <span class="n">root</span> <span class="o">=</span> <span class="n">start</span>
          <span class="n">child</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">root</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="k">while</span> <span class="n">child</span><span class="o">&lt;=</span><span class="n">end</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">child</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                  <span class="n">child</span> <span class="o">+=</span> <span class="mi">1</span>
              <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
                  <span class="n">nums</span><span class="p">[</span><span class="n">root</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">child</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>
                  <span class="n">root</span> <span class="o">=</span> <span class="n">child</span>
                  <span class="n">child</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">root</span> <span class="o">+</span> <span class="mi">1</span>
              <span class="k">else</span><span class="p">:</span>
                  <span class="k">break</span>
              <span class="c1"># 这个地方也可以写成递归写法，一样的道理，就是重复执行。           
</span>      <span class="c1"># 从底部开始排序得到最大堆
</span>      <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">sift_down</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="c1"># 取出堆顶元素，再次调整置换后的堆顶元素的位置。
</span>      <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">end</span><span class="p">],</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">sift_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>基数排序（Radix Sort）</strong></p>

    <p>思路：对正整数，将所有的数统一为一样的数位长度，短数补零。从最后的（最低位）开始排序到最高位数。由于该算法比较依赖整数的位数，所以时间复杂度为$O(kn)$，其中k为位数，n为元素个数。</p>

    <p>python：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="k">def</span> <span class="nf">radix_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">radix</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
      <span class="c1"># 求该数组的最大数的位数
</span>      <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">radix</span><span class="p">)))</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">bucket</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">radix</span><span class="p">)]</span>
          <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
              <span class="n">bucket</span><span class="p">[</span><span class="n">val</span><span class="o">%</span><span class="p">(</span><span class="n">radix</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="n">radix</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))].</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
          <span class="n">nums</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
              <span class="n">nums</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>计数排序</strong></p>

    <p>思路：开辟额外的内存空间来存储数组元素，即通过一个最大值-最小值的数组来放置原来数组的元素。该算法的时间复杂度为$O(n+k)$，其中n为数组元素个数，k为最大最小元素差值。</p>

    <p>python：</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
      <span class="n">n</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
      <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="n">l</span><span class="p">)]</span>
      <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
          <span class="n">temp</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
          <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
              <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">l</span>
          <span class="n">temp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">nums</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>桶排序</strong></p>

    <p>思路：如果排序的数组是均匀分布的，可以将数组分配到有限数量的桶中，对每个桶在进行排序，采用别的算法或者递归方式。桶排序其实是聚合的计数排序，复杂度是一样的。</p>

    <p>python:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bucket_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="n">bucketSize</span><span class="p">):</span>
      <span class="n">l</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
      <span class="n">bucketNum</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">//</span><span class="n">bucketSize</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucketNum</span><span class="p">)]</span>
      <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
          <span class="n">buckets</span><span class="p">[(</span><span class="n">num</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">//</span> <span class="n">bucketSize</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">bucket</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> 
              <span class="k">continue</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">res</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bucket_sort</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">bucketSize</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">res</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Bogo排序</strong></p>

    <p>思路：将所有数字混乱一次，然后检查是否排列好，否则就再混乱一次。</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">bogo_sort</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
      <span class="k">while</span> <span class="ow">not</span> <span class="n">in_order</span><span class="p">(</span><span class="n">my_list</span><span class="p">):</span>
          <span class="n">shuffle</span><span class="p">(</span><span class="n">my_list</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>


        </div>
        <br><br>
      </article>

      <nav class="post-pagination">
        
        
        <a href="/study/leetcode-recorder-02.html" class="btn next" title="leetcode algorithm-02">leetcode algorithm-02 &rarr;</a>
        
      </nav>

      <hr>

      
      <aside class="related">
        <h3>Related Posts</h3>
        <ul class="related-posts">
          
            <li>
              <a href="/study/leetcode-recorder-09.html">
                leetcode algorithm-09
                <small><time datetime="2020-07-01T00:00:00+08:00">01 Jul 2020</time></small>
              </a>
            </li>
          
            <li>
              <a href="/competition/As-a-rookie-firstAK.html">
                record of my first AK
                <small><time datetime="2020-06-28T00:00:00+08:00">28 Jun 2020</time></small>
              </a>
            </li>
          
            <li>
              <a href="/study/leetcode-recorder-08.html">
                leetcode algorithm-08
                <small><time datetime="2020-06-24T00:00:00+08:00">24 Jun 2020</time></small>
              </a>
            </li>
          
        </ul>
      </aside>
      

      <!-- <!-- Gitment
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '页面 ID', // 可选。默认为 location.href
  owner: 'lszero',
  repo: 'lszero.github.io',
  oauth: {
    client_id: '5cbd280dd9b27339aee6',
    client_secret: '18164941d46a714a7577cb7d14e642936ad2ac16',
  },
})
gitment.render('container')
</script> --> -->
    </div>
    
    <div class="col-md-3 post-sidebar">
      <div class="sidebar-content" id="sidebar">
  <nav class="header-list-sidebar">
    <ul id="sideNav" class="nav headers-sidenav">
        <!-- code will be generated in TOC.js -->
    </ul>
  </nav>
</div>
    </div>
  </div>
</div>


    <footer class="footer">
  <div class="copyright">
      Copyright &copy; <time datetime="2020-07-24T17:19:11+08:00">2020</time> <a href="http://localhost:4000">cxcacac</a> | Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> | Designed by <a href="http://localhost:4000">cxcacac</a>
  </div>
</footer>

    <a href="#top" class="back-to-top">^</a>

<!--      -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="/assets/js/jquery-1.12.4.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/assets/bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <!-- TOC -->
    <script src="/assets/js/toc/TOC.js"></script>

    <script>$("#search-form").submit(function(event){
      var query = document.getElementById("search-input").value;
      window.open("http://google.com/search?q=" + query + "%20site:" + "cxcacac.github.io");
    });</script>
  </body>
</html>
